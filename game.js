// Enhanced Chess Game with Drag & Drop and Advanced Features\nclass ChessGame {\n    constructor() {\n        this.board = this.initializeBoard();\n        this.currentPlayer = 'white';\n        this.selectedSquare = null;\n        this.validMoves = [];\n        this.gameMode = 'ai'; // 'ai' or 'human'\n        this.playerColor = 'white';\n        this.moveHistory = [];\n        this.capturedPieces = { white: [], black: [] };\n        this.gameState = 'playing'; // 'playing', 'check', 'checkmate', 'stalemate'\n        this.lastMove = null;\n        this.boardFlipped = false;\n        this.settings = {\n            boardTheme: 'classic',\n            pieceStyle: 'classic',\n            difficulty: 'medium',\n            enableSound: true,\n            enableAnimations: true,\n            showLegalMoves: true,\n            enableDragDrop: true\n        };\n        \n        // Drag and drop state\n        this.draggedPiece = null;\n        this.draggedFrom = null;\n        this.dragOffset = { x: 0, y: 0 };\n        \n        // Game statistics\n        this.gameStats = {\n            totalMoves: 0,\n            captures: 0,\n            checks: 0,\n            startTime: null,\n            endTime: null\n        };\n        \n        // Sound effects (using Web Audio API)\n        this.audioContext = null;\n        this.sounds = {};\n        \n        this.engine = new ChessEngine(this.settings.difficulty);\n        this.initializeGame();\n    }\n    \n    initializeBoard() {\n        const board = Array(8).fill(null).map(() => Array(8).fill(null));\n        \n        // Place pieces in starting position\n        // Black pieces (top)\n        board[0] = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'];\n        board[1] = Array(8).fill('p');\n        \n        // White pieces (bottom)\n        board[6] = Array(8).fill('P');\n        board[7] = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'];\n        \n        return board;\n    }\n    \n    async initializeGame() {\n        this.gameStats.startTime = Date.now();\n        await this.initializeAudio();\n        this.createBoard();\n        this.updateDisplay();\n        this.bindEvents();\n        this.applyTheme();\n    }\n    \n    async initializeAudio() {\n        try {\n            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            this.sounds = {\n                move: await this.createTone(400, 0.1),\n                capture: await this.createTone(600, 0.15),\n                check: await this.createTone(800, 0.2),\n                gameOver: await this.createTone(200, 0.5)\n            };\n        } catch (error) {\n            console.warn('Audio initialization failed:', error);\n        }\n    }\n    \n    async createTone(frequency, duration) {\n        if (!this.audioContext) return null;\n        \n        const oscillator = this.audioContext.createOscillator();\n        const gainNode = this.audioContext.createGain();\n        \n        oscillator.connect(gainNode);\n        gainNode.connect(this.audioContext.destination);\n        \n        oscillator.frequency.value = frequency;\n        oscillator.type = 'sine';\n        \n        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);\n        gainNode.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.01);\n        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);\n        \n        return { oscillator, gainNode, frequency, duration };\n    }\n    \n    playSound(soundName) {\n        if (!this.settings.enableSound || !this.audioContext || !this.sounds[soundName]) return;\n        \n        try {\n            const sound = this.sounds[soundName];\n            const oscillator = this.audioContext.createOscillator();\n            const gainNode = this.audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(this.audioContext.destination);\n            \n            oscillator.frequency.value = sound.frequency;\n            oscillator.type = 'sine';\n            \n            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);\n            gainNode.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.01);\n            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + sound.duration);\n            \n            oscillator.start(this.audioContext.currentTime);\n            oscillator.stop(this.audioContext.currentTime + sound.duration);\n        } catch (error) {\n            console.warn('Sound playback failed:', error);\n        }\n    }\n    \n    createBoard() {\n        const boardElement = document.getElementById('chessBoard');\n        boardElement.innerHTML = '';\n        \n        for (let row = 0; row < 8; row++) {\n            for (let col = 0; col < 8; col++) {\n                const square = document.createElement('div');\n                square.className = 'square';\n                square.dataset.row = row;\n                square.dataset.col = col;\n                \n                // Add alternating colors\n                if ((row + col) % 2 === 0) {\n                    square.classList.add('light');\n                } else {\n                    square.classList.add('dark');\n                }\n                \n                // Add event listeners\n                square.addEventListener('click', (e) => this.handleSquareClick(e));\n                \n                // Drag and drop event listeners\n                square.addEventListener('dragover', (e) => this.handleDragOver(e));\n                square.addEventListener('drop', (e) => this.handleDrop(e));\n                square.addEventListener('dragenter', (e) => this.handleDragEnter(e));\n                square.addEventListener('dragleave', (e) => this.handleDragLeave(e));\n                \n                boardElement.appendChild(square);\n            }\n        }\n        \n        this.updatePieces();\n    }\n    \n    updatePieces() {\n        const squares = document.querySelectorAll('.square');\n        squares.forEach(square => {\n            const row = parseInt(square.dataset.row);\n            const col = parseInt(square.dataset.col);\n            const piece = this.board[row][col];\n            \n            // Clear previous piece\n            square.innerHTML = '';\n            \n            if (piece) {\n                const pieceElement = document.createElement('div');\n                pieceElement.className = 'piece';\n                pieceElement.innerHTML = this.getPieceSymbol(piece);\n                pieceElement.draggable = this.settings.enableDragDrop;\n                \n                // Add drag event listeners\n                if (this.settings.enableDragDrop) {\n                    pieceElement.addEventListener('dragstart', (e) => this.handleDragStart(e, row, col));\n                    pieceElement.addEventListener('dragend', (e) => this.handleDragEnd(e));\n                }\n                \n                square.appendChild(pieceElement);\n            }\n        });\n    }\n    \n    getPieceSymbol(piece) {\n        const pieces = {\n            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',\n            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'\n        };\n        return pieces[piece] || '';\n    }\n    \n    // Enhanced drag and drop handlers\n    handleDragStart(event, row, col) {\n        if (this.gameState !== 'playing') {\n            event.preventDefault();\n            return;\n        }\n        \n        if (this.gameMode === 'ai' && this.currentPlayer !== this.playerColor) {\n            event.preventDefault();\n            return;\n        }\n        \n        const piece = this.board[row][col];\n        if (!piece || !this.isPieceOwnedByCurrentPlayer(piece)) {\n            event.preventDefault();\n            return;\n        }\n        \n        this.draggedPiece = piece;\n        this.draggedFrom = { row, col };\n        \n        // Set drag data\n        event.dataTransfer.setData('text/plain', `${row},${col}`);\n        event.dataTransfer.effectAllowed = 'move';\n        \n        // Add dragging class\n        event.target.classList.add('dragging');\n        \n        // Clear previous selection and show valid moves\n        this.clearSelection();\n        this.selectedSquare = { row, col };\n        this.validMoves = this.getValidMoves(row, col);\n        \n        if (this.settings.showLegalMoves) {\n            this.highlightValidMoves();\n        }\n        \n        // Create drag image\n        const dragImage = event.target.cloneNode(true);\n        dragImage.style.transform = 'scale(1.2)';\n        dragImage.style.opacity = '0.8';\n        event.dataTransfer.setDragImage(dragImage, 30, 30);\n        \n        setTimeout(() => {\n            if (dragImage.parentNode) {\n                dragImage.parentNode.removeChild(dragImage);\n            }\n        }, 0);\n    }\n    \n    handleDragEnd(event) {\n        event.target.classList.remove('dragging');\n        this.clearDragHighlights();\n        \n        if (!this.draggedPiece) {\n            this.clearSelection();\n        }\n        \n        this.draggedPiece = null;\n        this.draggedFrom = null;\n    }\n    \n    handleDragOver(event) {\n        event.preventDefault();\n        event.dataTransfer.dropEffect = 'move';\n    }\n    \n    handleDragEnter(event) {\n        event.preventDefault();\n        \n        if (this.draggedPiece) {\n            const row = parseInt(event.currentTarget.dataset.row);\n            const col = parseInt(event.currentTarget.dataset.col);\n            \n            if (this.isValidMove(this.draggedFrom.row, this.draggedFrom.col, row, col)) {\n                event.currentTarget.classList.add('drag-over');\n            } else {\n                event.currentTarget.classList.add('drag-invalid');\n            }\n        }\n    }\n    \n    handleDragLeave(event) {\n        event.currentTarget.classList.remove('drag-over', 'drag-invalid');\n    }\n    \n    handleDrop(event) {\n        event.preventDefault();\n        \n        const row = parseInt(event.currentTarget.dataset.row);\n        const col = parseInt(event.currentTarget.dataset.col);\n        \n        event.currentTarget.classList.remove('drag-over', 'drag-invalid');\n        \n        if (this.draggedPiece && this.draggedFrom) {\n            if (this.isValidMove(this.draggedFrom.row, this.draggedFrom.col, row, col)) {\n                this.makeMove(this.draggedFrom.row, this.draggedFrom.col, row, col);\n                this.clearSelection();\n                \n                // If playing against AI, trigger AI move\n                if (this.gameMode === 'ai' && this.currentPlayer !== this.playerColor) {\n                    setTimeout(() => this.makeAIMove(), 500);\n                }\n            }\n        }\n    }\n    \n    clearDragHighlights() {\n        document.querySelectorAll('.square').forEach(square => {\n            square.classList.remove('drag-over', 'drag-invalid');\n        });\n    }\n    \n    handleSquareClick(event) {\n        const square = event.currentTarget;\n        const row = parseInt(square.dataset.row);\n        const col = parseInt(square.dataset.col);\n        \n        if (this.gameState !== 'playing') return;\n        \n        // If it's AI's turn, don't allow human moves\n        if (this.gameMode === 'ai' && this.currentPlayer !== this.playerColor) {\n            return;\n        }\n        \n        if (this.selectedSquare) {\n            // Try to make a move\n            if (this.isValidMove(this.selectedSquare.row, this.selectedSquare.col, row, col)) {\n                this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);\n                this.clearSelection();\n                \n                // If playing against AI, trigger AI move\n                if (this.gameMode === 'ai' && this.currentPlayer !== this.playerColor) {\n                    setTimeout(() => this.makeAIMove(), 500);\n                }\n            } else {\n                // Select new piece or deselect\n                this.selectSquare(row, col);\n            }\n        } else {\n            // Select a piece\n            this.selectSquare(row, col);\n        }\n    }\n    \n    selectSquare(row, col) {\n        const piece = this.board[row][col];\n        \n        // Clear previous selection\n        this.clearSelection();\n        \n        // Check if the piece belongs to the current player\n        if (piece && this.isPieceOwnedByCurrentPlayer(piece)) {\n            this.selectedSquare = { row, col };\n            this.validMoves = this.getValidMoves(row, col);\n            this.highlightSquare(row, col, 'selected');\n            \n            if (this.settings.showLegalMoves) {\n                this.highlightValidMoves();\n            }\n        }\n    }\n    \n    clearSelection() {\n        document.querySelectorAll('.square').forEach(square => {\n            square.classList.remove('selected', 'valid-move', 'capture-move');\n        });\n        this.selectedSquare = null;\n        this.validMoves = [];\n    }\n    \n    highlightSquare(row, col, className) {\n        const square = document.querySelector(`[data-row=\"${row}\"][data-col=\"${col}\"]`);\n        if (square) {\n            square.classList.add(className);\n        }\n    }\n    \n    highlightValidMoves() {\n        this.validMoves.forEach(move => {\n            const square = document.querySelector(`[data-row=\"${move.row}\"][data-col=\"${move.col}\"]`);\n            if (square) {\n                if (this.board[move.row][move.col]) {\n                    square.classList.add('capture-move');\n                } else {\n                    square.classList.add('valid-move');\n                }\n            }\n        });\n    }\n    \n    isValidMove(fromRow, fromCol, toRow, toCol) {\n        return this.validMoves.some(move => move.row === toRow && move.col === toCol);\n    }\n    \n    makeMove(fromRow, fromCol, toRow, toCol) {\n        const piece = this.board[fromRow][fromCol];\n        const capturedPiece = this.board[toRow][toCol];\n        \n        // Handle captured piece\n        if (capturedPiece) {\n            const capturedColor = capturedPiece === capturedPiece.toUpperCase() ? 'white' : 'black';\n            this.capturedPieces[capturedColor].push(capturedPiece);\n            this.updateCapturedPieces();\n            this.gameStats.captures++;\n            this.playSound('capture');\n        } else {\n            this.playSound('move');\n        }\n        \n        // Make the move\n        this.board[toRow][toCol] = piece;\n        this.board[fromRow][fromCol] = null;\n        \n        // Record move\n        const moveNotation = this.getMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece);\n        this.moveHistory.push({\n            from: { row: fromRow, col: fromCol },\n            to: { row: toRow, col: toCol },\n            piece: piece,\n            captured: capturedPiece,\n            notation: moveNotation,\n            timestamp: Date.now()\n        });\n        \n        this.gameStats.totalMoves++;\n        \n        // Update last move highlighting\n        this.lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };\n        this.highlightLastMove();\n        \n        // Animate the move\n        if (this.settings.enableAnimations) {\n            this.animateMove(fromRow, fromCol, toRow, toCol);\n        }\n        \n        // Switch players\n        this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';\n        \n        // Update display\n        this.updateDisplay();\n        this.updatePieces();\n        \n        // Check for game end conditions\n        this.checkGameState();\n    }\n    \n    makeAIMove() {\n        if (this.gameState !== 'playing') return;\n        \n        // Show thinking animation\n        const boardElement = document.getElementById('chessBoard');\n        boardElement.classList.add('thinking');\n        \n        // Get AI move with dynamic thinking time based on difficulty\n        const thinkingTime = {\n            'easy': 500,\n            'medium': 1000,\n            'hard': 2000\n        }[this.settings.difficulty] || 1000;\n        \n        setTimeout(() => {\n            const aiMove = this.engine.getBestMove(this.board, this.currentPlayer === 'white');\n            \n            if (aiMove) {\n                this.makeMove(aiMove.from.row, aiMove.from.col, aiMove.to.row, aiMove.to.col);\n            }\n            \n            boardElement.classList.remove('thinking');\n        }, thinkingTime);\n    }\n    \n    animateMove(fromRow, fromCol, toRow, toCol) {\n        const fromSquare = document.querySelector(`[data-row=\"${fromRow}\"][data-col=\"${fromCol}\"]`);\n        const toSquare = document.querySelector(`[data-row=\"${toRow}\"][data-col=\"${toCol}\"]`);\n        \n        if (fromSquare && toSquare) {\n            const piece = fromSquare.querySelector('.piece');\n            if (piece) {\n                piece.classList.add('piece-moved');\n                setTimeout(() => {\n                    piece.classList.remove('piece-moved');\n                }, 600);\n            }\n        }\n    }\n    \n    highlightLastMove() {\n        // Clear previous last move highlights\n        document.querySelectorAll('.last-move').forEach(square => {\n            square.classList.remove('last-move');\n        });\n        \n        if (this.lastMove) {\n            this.highlightSquare(this.lastMove.from.row, this.lastMove.from.col, 'last-move');\n            this.highlightSquare(this.lastMove.to.row, this.lastMove.to.col, 'last-move');\n        }\n    }\n    \n    getValidMoves(row, col) {\n        const moves = this.engine.getValidMoves(this.board, row, col);\n        return moves.map(move => move.to);\n    }\n    \n    isPieceOwnedByCurrentPlayer(piece) {\n        const isWhitePiece = piece === piece.toUpperCase();\n        return (this.currentPlayer === 'white' && isWhitePiece) || \n               (this.currentPlayer === 'black' && !isWhitePiece);\n    }\n    \n    getMoveNotation(fromRow, fromCol, toRow, toCol, piece, captured) {\n        const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n        const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];\n        \n        const fromSquare = files[fromCol] + ranks[fromRow];\n        const toSquare = files[toCol] + ranks[toRow];\n        \n        let notation = '';\n        \n        if (piece.toLowerCase() !== 'p') {\n            notation += piece.toUpperCase();\n        }\n        \n        if (captured) {\n            if (piece.toLowerCase() === 'p') {\n                notation += files[fromCol];\n            }\n            notation += 'x';\n        }\n        \n        notation += toSquare;\n        \n        // Check for check or checkmate\n        if (this.engine.isInCheck(this.board, this.currentPlayer === 'white')) {\n            const nextPlayerMoves = this.engine.getAllValidMoves(this.board, this.currentPlayer === 'white');\n            if (nextPlayerMoves.length === 0) {\n                notation += '#'; // Checkmate\n            } else {\n                notation += '+'; // Check\n                this.gameStats.checks++;\n                this.playSound('check');\n            }\n        }\n        \n        return notation;\n    }\n    \n    updateDisplay() {\n        // Update current turn\n        document.getElementById('currentTurn').textContent = \n            this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1);\n        \n        // Update move history\n        this.updateMoveHistory();\n        \n        // Update game mode display\n        document.getElementById('gameMode').textContent = \n            this.gameMode === 'ai' ? 'vs AI' : 'vs Human';\n        \n        // Update difficulty display\n        document.getElementById('difficulty').textContent = \n            this.settings.difficulty.charAt(0).toUpperCase() + this.settings.difficulty.slice(1);\n        \n        // Update game statistics\n        this.updateGameStats();\n    }\n    \n    updateGameStats() {\n        const statsElements = {\n            totalMoves: document.getElementById('totalMoves'),\n            captures: document.getElementById('captures'),\n            checks: document.getElementById('checks'),\n            gameTime: document.getElementById('gameTime')\n        };\n        \n        if (statsElements.totalMoves) {\n            statsElements.totalMoves.textContent = this.gameStats.totalMoves;\n        }\n        \n        if (statsElements.captures) {\n            statsElements.captures.textContent = this.gameStats.captures;\n        }\n        \n        if (statsElements.checks) {\n            statsElements.checks.textContent = this.gameStats.checks;\n        }\n        \n        if (statsElements.gameTime && this.gameStats.startTime) {\n            const elapsed = Math.floor((Date.now() - this.gameStats.startTime) / 1000);\n            const minutes = Math.floor(elapsed / 60);\n            const seconds = elapsed % 60;\n            statsElements.gameTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;\n        }\n    }\n    \n    updateMoveHistory() {\n        const moveList = document.getElementById('moveList');\n        moveList.innerHTML = '';\n        \n        for (let i = 0; i < this.moveHistory.length; i += 2) {\n            const moveItem = document.createElement('div');\n            moveItem.className = 'move-item';\n            \n            const moveNumber = Math.floor(i / 2) + 1;\n            const whiteMove = this.moveHistory[i];\n            const blackMove = this.moveHistory[i + 1];\n            \n            moveItem.innerHTML = `\n                <span class=\"move-number\">${moveNumber}.</span>\n                <span>${whiteMove.notation} ${blackMove ? blackMove.notation : ''}</span>\n            `;\n            \n            // Add click handler for move replay\n            moveItem.addEventListener('click', () => {\n                this.showMoveDetails(moveNumber, whiteMove, blackMove);\n            });\n            \n            moveList.appendChild(moveItem);\n        }\n        \n        // Auto-scroll to bottom\n        moveList.scrollTop = moveList.scrollHeight;\n    }\n    \n    showMoveDetails(moveNumber, whiteMove, blackMove) {\n        // Create a tooltip or modal showing move details\n        const tooltip = document.createElement('div');\n        tooltip.className = 'tooltip show';\n        tooltip.innerHTML = `\n            <div><strong>Move ${moveNumber}</strong></div>\n            <div>White: ${whiteMove.notation}</div>\n            ${blackMove ? `<div>Black: ${blackMove.notation}</div>` : ''}\n            <div>Time: ${new Date(whiteMove.timestamp).toLocaleTimeString()}</div>\n        `;\n        \n        document.body.appendChild(tooltip);\n        \n        // Position tooltip\n        const rect = event.target.getBoundingClientRect();\n        tooltip.style.left = rect.left + 'px';\n        tooltip.style.top = (rect.top - tooltip.offsetHeight - 10) + 'px';\n        \n        // Remove tooltip after 3 seconds\n        setTimeout(() => {\n            if (tooltip.parentNode) {\n                tooltip.parentNode.removeChild(tooltip);\n            }\n        }, 3000);\n    }\n    \n    updateCapturedPieces() {\n        const topCaptured = document.getElementById('topCaptured');\n        const bottomCaptured = document.getElementById('bottomCaptured');\n        \n        const playerCaptured = this.playerColor === 'white' ? 'black' : 'white';\n        const opponentCaptured = this.playerColor === 'white' ? 'white' : 'black';\n        \n        topCaptured.innerHTML = this.capturedPieces[opponentCaptured]\n            .map(piece => `<span class=\"captured-piece\">${this.getPieceSymbol(piece)}</span>`)\n            .join('');\n        \n        bottomCaptured.innerHTML = this.capturedPieces[playerCaptured]\n            .map(piece => `<span class=\"captured-piece\">${this.getPieceSymbol(piece)}</span>`)\n            .join('');\n    }\n    \n    checkGameState() {\n        const currentPlayerMoves = this.engine.getAllValidMoves(this.board, this.currentPlayer === 'white');\n        \n        if (currentPlayerMoves.length === 0) {\n            if (this.engine.isInCheck(this.board, this.currentPlayer === 'white')) {\n                this.gameState = 'checkmate';\n                this.gameStats.endTime = Date.now();\n                this.showGameOver(this.currentPlayer === 'white' ? 'Black' : 'White', 'checkmate');\n                this.playSound('gameOver');\n            } else {\n                this.gameState = 'stalemate';\n                this.gameStats.endTime = Date.now();\n                this.showGameOver('Draw', 'stalemate');\n                this.playSound('gameOver');\n            }\n        } else if (this.engine.isInCheck(this.board, this.currentPlayer === 'white')) {\n            this.gameState = 'check';\n            this.highlightKingInCheck();\n        } else {\n            this.gameState = 'playing';\n            this.clearCheckHighlight();\n        }\n    }\n    \n    highlightKingInCheck() {\n        const kingSymbol = this.currentPlayer === 'white' ? 'K' : 'k';\n        \n        for (let row = 0; row < 8; row++) {\n            for (let col = 0; col < 8; col++) {\n                if (this.board[row][col] === kingSymbol) {\n                    this.highlightSquare(row, col, 'in-check');\n                    break;\n                }\n            }\n        }\n    }\n    \n    clearCheckHighlight() {\n        document.querySelectorAll('.in-check').forEach(square => {\n            square.classList.remove('in-check');\n        });\n    }\n    \n    showGameOver(winner, reason) {\n        const gameOverElement = document.createElement('div');\n        gameOverElement.className = 'game-over';\n        \n        const reasonText = {\n            'checkmate': 'by Checkmate',\n            'stalemate': 'by Stalemate',\n            'timeout': 'by Timeout',\n            'resignation': 'by Resignation'\n        }[reason] || '';\n        \n        const gameTime = this.gameStats.endTime ? \n            Math.floor((this.gameStats.endTime - this.gameStats.startTime) / 1000) : 0;\n        const minutes = Math.floor(gameTime / 60);\n        const seconds = gameTime % 60;\n        \n        gameOverElement.innerHTML = `\n            <div class=\"game-over-content\">\n                <h2>Game Over</h2>\n                <p>${winner === 'Draw' ? 'Draw' : winner + ' wins'} ${reasonText}</p>\n                <div class=\"game-stats\">\n                    <p>Total Moves: ${this.gameStats.totalMoves}</p>\n                    <p>Captures: ${this.gameStats.captures}</p>\n                    <p>Checks: ${this.gameStats.checks}</p>\n                    <p>Game Time: ${minutes}:${seconds.toString().padStart(2, '0')}</p>\n                </div>\n                <div class=\"game-over-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"game.newGame()\">New Game</button>\n                    <button class=\"btn btn-secondary\" onclick=\"game.analyzeGame()\">Analyze</button>\n                </div>\n            </div>\n        `;\n        document.body.appendChild(gameOverElement);\n    }\n    \n    analyzeGame() {\n        // Simple game analysis\n        const analysis = {\n            totalMoves: this.gameStats.totalMoves,\n            captures: this.gameStats.captures,\n            checks: this.gameStats.checks,\n            averageTimePerMove: this.gameStats.endTime ? \n                (this.gameStats.endTime - this.gameStats.startTime) / this.gameStats.totalMoves : 0,\n            openingMoves: this.moveHistory.slice(0, 10).map(m => m.notation).join(' '),\n            longestSequence: this.findLongestSequenceWithoutCapture()\n        };\n        \n        alert(`Game Analysis:\n\nTotal Moves: ${analysis.totalMoves}\nCaptures: ${analysis.captures}\nChecks: ${analysis.checks}\nAverage Time per Move: ${Math.round(analysis.averageTimePerMove / 1000)}s\nOpening: ${analysis.openingMoves}\nLongest Sequence without Capture: ${analysis.longestSequence} moves`);\n    }\n    \n    findLongestSequenceWithoutCapture() {\n        let maxSequence = 0;\n        let currentSequence = 0;\n        \n        for (const move of this.moveHistory) {\n            if (move.captured) {\n                maxSequence = Math.max(maxSequence, currentSequence);\n                currentSequence = 0;\n            } else {\n                currentSequence++;\n            }\n        }\n        \n        return Math.max(maxSequence, currentSequence);\n    }\n    \n    flipBoard() {\n        this.boardFlipped = !this.boardFlipped;\n        const boardElement = document.getElementById('chessBoard');\n        \n        if (this.boardFlipped) {\n            boardElement.style.transform = 'rotate(180deg)';\n            // Rotate pieces back to normal\n            document.querySelectorAll('.piece').forEach(piece => {\n                piece.style.transform = 'rotate(180deg)';\n            });\n        } else {\n            boardElement.style.transform = 'rotate(0deg)';\n            document.querySelectorAll('.piece').forEach(piece => {\n                piece.style.transform = 'rotate(0deg)';\n            });\n        }\n        \n        this.updateCoordinates();\n    }\n    \n    updateCoordinates() {\n        const leftCoords = document.querySelectorAll('.coordinates-left .coord');\n        const bottomCoords = document.querySelectorAll('.coordinates-bottom .coord');\n        \n        if (this.boardFlipped) {\n            leftCoords.forEach((coord, index) => {\n                coord.textContent = index + 1;\n            });\n            bottomCoords.forEach((coord, index) => {\n                coord.textContent = String.fromCharCode(104 - index); // h to a\n            });\n        } else {\n            leftCoords.forEach((coord, index) => {\n                coord.textContent = 8 - index;\n            });\n            bottomCoords.forEach((coord, index) => {\n                coord.textContent = String.fromCharCode(97 + index); // a to h\n            });\n        }\n    }\n    \n    newGame() {\n        // Remove game over screen\n        const gameOverElement = document.querySelector('.game-over');\n        if (gameOverElement) {\n            gameOverElement.remove();\n        }\n        \n        // Reset game state\n        this.board = this.initializeBoard();\n        this.currentPlayer = 'white';\n        this.selectedSquare = null;\n        this.validMoves = [];\n        this.moveHistory = [];\n        this.capturedPieces = { white: [], black: [] };\n        this.gameState = 'playing';\n        this.lastMove = null;\n        \n        // Reset game statistics\n        this.gameStats = {\n            totalMoves: 0,\n            captures: 0,\n            checks: 0,\n            startTime: Date.now(),\n            endTime: null\n        };\n        \n        // Update display\n        this.updatePieces();\n        this.updateDisplay();\n        this.updateCapturedPieces();\n        this.clearSelection();\n        this.clearCheckHighlight();\n        \n        // Clear last move highlights\n        document.querySelectorAll('.last-move').forEach(square => {\n            square.classList.remove('last-move');\n        });\n    }\n    \n    applySettings(settings) {\n        this.settings = { ...this.settings, ...settings };\n        \n        // Update AI difficulty\n        this.engine.setDifficulty(this.settings.difficulty);\n        \n        // Update game mode\n        this.gameMode = settings.gameMode || this.gameMode;\n        \n        // Update player color\n        if (settings.playerColor && settings.playerColor !== this.playerColor) {\n            this.playerColor = settings.playerColor;\n            this.updatePlayerInfo();\n        }\n        \n        // Apply visual themes\n        this.applyTheme();\n        \n        // Update pieces for drag and drop\n        this.updatePieces();\n        \n        // Update display\n        this.updateDisplay();\n    }\n    \n    applyTheme() {\n        const boardElement = document.getElementById('chessBoard');\n        \n        // Remove existing theme classes\n        boardElement.classList.remove('classic', 'modern', 'dark', 'neon');\n        \n        // Add new theme\n        boardElement.classList.add(this.settings.boardTheme);\n        \n        // Apply animations setting\n        if (!this.settings.enableAnimations) {\n            document.body.classList.add('no-animations');\n        } else {\n            document.body.classList.remove('no-animations');\n        }\n    }\n    \n    updatePlayerInfo() {\n        const topPlayer = document.getElementById('topPlayer');\n        const bottomPlayer = document.getElementById('bottomPlayer');\n        \n        if (this.playerColor === 'white') {\n            topPlayer.querySelector('.player-name').textContent = \n                this.gameMode === 'ai' ? 'AI Opponent' : 'Player 2';\n            bottomPlayer.querySelector('.player-name').textContent = \n                this.gameMode === 'ai' ? 'You' : 'Player 1';\n        } else {\n            topPlayer.querySelector('.player-name').textContent = \n                this.gameMode === 'ai' ? 'You' : 'Player 1';\n            bottomPlayer.querySelector('.player-name').textContent = \n                this.gameMode === 'ai' ? 'AI Opponent' : 'Player 2';\n        }\n    }\n    \n    bindEvents() {\n        // New Game button\n        document.getElementById('newGameBtn').addEventListener('click', () => {\n            this.newGame();\n        });\n        \n        // Flip Board button\n        document.getElementById('flipBoardBtn').addEventListener('click', () => {\n            this.flipBoard();\n        });\n        \n        // Settings button\n        document.getElementById('settingsBtn').addEventListener('click', () => {\n            this.showSettings();\n        });\n        \n        // Settings modal events\n        document.getElementById('closeSettings').addEventListener('click', () => {\n            this.hideSettings();\n        });\n        \n        document.getElementById('cancelSettings').addEventListener('click', () => {\n            this.hideSettings();\n        });\n        \n        document.getElementById('applySettings').addEventListener('click', () => {\n            this.applySettingsFromModal();\n        });\n        \n        // Close modal when clicking outside\n        document.getElementById('settingsModal').addEventListener('click', (e) => {\n            if (e.target.id === 'settingsModal') {\n                this.hideSettings();\n            }\n        });\n        \n        // Keyboard shortcuts\n        document.addEventListener('keydown', (e) => {\n            this.handleKeyPress(e);\n        });\n    }\n    \n    handleKeyPress(event) {\n        // ESC to clear selection\n        if (event.key === 'Escape') {\n            this.clearSelection();\n        }\n        \n        // N for new game\n        if (event.key === 'n' || event.key === 'N') {\n            if (event.ctrlKey || event.metaKey) {\n                event.preventDefault();\n                this.newGame();\n            }\n        }\n        \n        // F for flip board\n        if (event.key === 'f' || event.key === 'F') {\n            if (event.ctrlKey || event.metaKey) {\n                event.preventDefault();\n                this.flipBoard();\n            }\n        }\n        \n        // S for settings\n        if (event.key === 's' || event.key === 'S') {\n            if (event.ctrlKey || event.metaKey) {\n                event.preventDefault();\n                this.showSettings();\n            }\n        }\n    }\n    \n    showSettings() {\n        const modal = document.getElementById('settingsModal');\n        \n        // Populate current settings\n        document.getElementById('gameModeSelect').value = this.gameMode;\n        document.getElementById('difficultySelect').value = this.settings.difficulty;\n        document.getElementById('playerColorSelect').value = this.playerColor;\n        document.getElementById('boardThemeSelect').value = this.settings.boardTheme;\n        document.getElementById('pieceStyleSelect').value = this.settings.pieceStyle;\n        \n        // Add advanced settings if elements exist\n        const soundToggle = document.getElementById('enableSoundToggle');\n        const animationsToggle = document.getElementById('enableAnimationsToggle');\n        const legalMovesToggle = document.getElementById('showLegalMovesToggle');\n        const dragDropToggle = document.getElementById('enableDragDropToggle');\n        \n        if (soundToggle) soundToggle.checked = this.settings.enableSound;\n        if (animationsToggle) animationsToggle.checked = this.settings.enableAnimations;\n        if (legalMovesToggle) legalMovesToggle.checked = this.settings.showLegalMoves;\n        if (dragDropToggle) dragDropToggle.checked = this.settings.enableDragDrop;\n        \n        modal.style.display = 'flex';\n    }\n    \n    hideSettings() {\n        const modal = document.getElementById('settingsModal');\n        modal.style.display = 'none';\n    }\n    \n    applySettingsFromModal() {\n        const newSettings = {\n            gameMode: document.getElementById('gameModeSelect').value,\n            difficulty: document.getElementById('difficultySelect').value,\n            playerColor: document.getElementById('playerColorSelect').value,\n            boardTheme: document.getElementById('boardThemeSelect').value,\n            pieceStyle: document.getElementById('pieceStyleSelect').value\n        };\n        \n        // Add advanced settings\n        const soundToggle = document.getElementById('enableSoundToggle');\n        const animationsToggle = document.getElementById('enableAnimationsToggle');\n        const legalMovesToggle = document.getElementById('showLegalMovesToggle');\n        const dragDropToggle = document.getElementById('enableDragDropToggle');\n        \n        if (soundToggle) newSettings.enableSound = soundToggle.checked;\n        if (animationsToggle) newSettings.enableAnimations = animationsToggle.checked;\n        if (legalMovesToggle) newSettings.showLegalMoves = legalMovesToggle.checked;\n        if (dragDropToggle) newSettings.enableDragDrop = dragDropToggle.checked;\n        \n        this.applySettings(newSettings);\n        this.hideSettings();\n    }\n    \n    // Utility methods\n    exportGame() {\n        const gameData = {\n            moves: this.moveHistory.map(m => m.notation),\n            result: this.gameState,\n            settings: this.settings,\n            stats: this.gameStats\n        };\n        \n        const blob = new Blob([JSON.stringify(gameData, null, 2)], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `chess-game-${new Date().toISOString().split('T')[0]}.json`;\n        a.click();\n        URL.revokeObjectURL(url);\n    }\n    \n    importGame(file) {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            try {\n                const gameData = JSON.parse(e.target.result);\n                // Implement game import logic here\n                console.log('Game imported:', gameData);\n            } catch (error) {\n                alert('Error importing game: ' + error.message);\n            }\n        };\n        reader.readAsText(file);\n    }\n}\n\n// Initialize game when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.game = new ChessGame();\n    \n    // Update game statistics every second\n    setInterval(() => {\n        if (window.game && window.game.gameStats.startTime && window.game.gameState === 'playing') {\n            window.game.updateGameStats();\n        }\n    }, 1000);\n});"